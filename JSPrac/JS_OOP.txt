** JS의 OOP객체 지향 프로그래밍, ES5까지는 클래스의 개념이 없어서 OOP의 개념이 아님 
   객체 기반 언어 ECMA 2015에서 클래스 개념이 도입됨

1. 객체지향의 3대 특징
  - Encapsulation(캡슐화) : 불필요한 부분을 숨기고 만드는 것
                            클래스를 만드는 것과 인스턴스를 만드는 것 그리고 지정자률 학습
    
  - Inheritance(상속) : 하위 클래스가 상위 클래스의 모든 것을 물려 받는 것

  - polymorphsim(다형성) : 동일한 메시지에 대해 다르게 반응하는 성질
                           동일은 코드가 호출하는 객체에 따라 다른 메서드를 호출하는 성질
                           상속과 오버라이딩(가끔은 오버라이딩이 아니라 구현)으로 구현됨

2. 객체(Object) : 데이터를 저장할 수 있는 속성(variable - property)과 기능을 수행하는 메서드(function - method)
                   모아 놓은 것.

                  종류
                  - 사용자 정의 객체 : 개발자가 필요에 의해서 생성하는 것
                                     
                                     생성
                                     - var(let or const) 이름 = {"속성이름" : 데이터, "메서드이름" : 메서드 코드..}
                                     - var(let or const) 이름 = new 생성자(매개변수 나열)
                                     
                                     내부 요소 호출
                                     - 이름.속성이름
                                     - 이름.메서드이름(매개변수)
                                     -> .이름 대신에 [속성이름]으로 속성 호출이 가능한데 이 때 문자열 형태로 입력해야 한다.
                                        var obj = {"name" : "adam"}; 
                                        obj.name == obj["name"]
                                     - 내부 속성은 중복해서 만들어지지 않으므로 동일한 이름에 2번 삽입하면 내용이 없어지고 새로운 내용으로 변경된다. 
                                     - for(임시변수 in 객체이름){수행할 내용} : 객체의 모든 속성의 이름을 임시변수에 문자열 형태로 대입하고 {}안의 내용을 반복수행
                                     - "속성이름" in 객체 : 속성이 객체에 존재하는지 여부를 판단해서 Boolean값으로 반환
                                     
                                     with 블럭
                                     - with(객체이름){ // 해당 블록 내에서는 객체이름 생략가능 }
                                     
                                     속성 추가 및 수정
                                     - 객체이름.속성이름 = 데이터 또는 함수; -> 존재하는 속성이면 수정이고 존재하지 않는 속성이면 해당 속성 추가
                                    
                                     속성 삭제
                                     - delete(객체이름.속성이름)
                                     
                                     this
                                     - 객체 안에 존재하는 메서드에 존재하는 숨겨진 매개변수
                                     - 객체 안에 만들어진 메서드에서는 this라는 변수를 사용할 수 있는데 이 this는 객체를 참조한다.
                                     - 객체 안에 만들어진 메서드에서 객체의 속성을 이용할 때는 this.속성이름 의 형태로 사용해야한다.
                                     - this를 붙이지 않으면 메서드 안에서 이름을 찾아야한다.
                                     - 화살표 함수에서는 this를 사용할 수 없기 때문에 위의 방법으로 찾아야함.

P.S. JS에서는 리터럴/상수/함수/클래스 등의 객체들이 정적 Heap에 올라가고 속성의 값인 인스턴스(데이터, 메서드)는 동적인 Heap공간에 들어가 있어서 찾아갈 방법이 없다.
     찾아 올 수 없다.
     JS에서 클래스나 객체에서 메서드를 생성 했을 때, 데이터나 메서드는 객체에 참조되어 진다, 이때 그 참조를 가리킬 수 있는 this나 super라는 도구가 있는 것이다.
     
     함수와 메서드의 차이는 호출자가 있으면 메서드 없으면 함수라고 보통한다.
     함수는 숨겨진 메서드가 없고, 있으면 숨겨진 매게변수(this, super)가 있다.
                                     
                                     constructor(생성자)
                                     - 생성자는 객체를 생성해서 메모리 할당을 하고 그 참조를 반환하는 함수
                                     - 일반 함수를 만드는 것과 동일한 방법으로 만드는데 객체를 생성하고자 하면 내부에서 this를 이용해서 필요한 속성과
                                       메서드를 정의하면 된다.
                                     - 생성자 호출 : new 생성자이름(매개변수)
                                     - 생성자(클래스)를 만드는 이유는 동일한 속성을 갖는 객체를 여러개 생성해야 하는 경우입니다.

                   - 내장 객체 : JS에서 제공하는 객체 - API(Application Programing Interface) 나 SDK(Software Development Kit)
                                라고 함
                   - 3rd Party객체 : 다른 개발자나 회사가 제공 (Library, Framework : Solution)
                                   라이브러리는 제 3자가 많이 쓰는 기능/틀을 제공하는 정도
                                   프레임워크는 프로젝트 하나를 만들 정도로 제공하는 정도
                                   솔루션은 학사정보 시스템과 같은 것을 만드는데 어느정도 핵심 틀이 있는 사람
    
3. Class : 유사한 모양의 객체를 만들기 위한 템플릿
           생성자를 이용해서도 생성이 가능하지만 생성자를 이용하게 되면 모든 멤버를 생성자 안에서 만들어야 하기 때문에 객체가 가져야하는
           메서드가 많아지면 코드의 가독성이 떨어진다.
           ECMA2015(=ES6)에서 Class문법을 추가 시켰다.

           선언
           - 기본적인 방법
             class 클래스 이름 {
                클래스 내용
              } 
                
          상속을 받는 경우
           class 클래스이름 extends 상위클래스 이름{
                    클래스 내용
            }
                
          표현식 이용
          let 이름 = class{클래스 내용}
          let 이름 = class 내부에서 사용할 이름{클래스 내용}

          클래스를 이용한 객체 생성
          - 클래스를 이용해서 생성된 객체를 instance라고 한다.

          - var i = 10, var j = new ?() -> i와 j 모두 객체에 해당되지만 j는 인스턴스이다. 
                  큰 차이는 new를 이용하면 동적 heap 영역에 생성되고, 단순 선언된 경우 정적 heap영역에 생성되는 것.
                
          - 클래스의 생성자는 클래스 이름과 동일하게 만들어지기 때문에 생성자 이름 대신에 클래스 이름을 기재해도 된다.
            var[let||const] 이름 = new 생성자이름(매개변수)에서 엄밀히 말하면 = 이후에 오는 것이 인스턴스에 해당되나 구별하진 않는다.
            new 연산자는 생성자를 호출해서 인스턴스를 동적인 heap 영역에 만들고 그 참조를 반환하는 연산자이다.

          클래스 안에 멤버 속성 만들기
          - 메서드 안에서 this와 이름을 만들면 인스턴스의 속성이 되는 것.

          JS에서 Class는 정적이지 않다. 즉, JS에서는 Class의 내용을 수정할 수 있다.(다른언어는 힘들다)
          기본적으로 Class는 생성되면 정적이다, JAVA 또한 마차가지로 Class는 한 번 생성되면 정적이다.
                
          JS는 Class가 prototype이라는 내부 객체를 이용해서 모든 속성을 저장하는데, prototype이 객체이므로 확장이 가능하디.
          클래스를 선언할 때는 없었는데 나중에 추가하거나 변경하고자 하면 클래스이름.prototype.속성이름 = 내용 과 같은 형태로 이미 선언된
          클래스에 동적으로 속성을 추가할 수 있다.
                
          이름
          - JS에서 변수, 함수, class가 모두 동일한 Lv로 기존의 이름에 값이 저장되어 있는데, 함수를 대입하면 기존 값은 사라지고 함수의 내용이
            저장된다.
                
          - 하나의 이름에 한 가지만 저장 가능 -> 중복 정의(OverLoading)이 안된다.
                  
          기존에 했던 언어들은 매개변수가 있는, 매개변수가 없는 동일한 이름의 함수에 대해 각 해당 하는 경우에만 적용되었다.(오버로딩)
          하지만 JS는 무조건 이름에 해당되는 것에 적용되기 때문에 오버로딩 되어지지 않고 그냥 함수를 덮어써버린다.
          즉, 같은 이름으로 함수f(), 함수f(n), 클래스f() 순으로 선언하면 결국 f는 클래스가 되어버린다.
          이때, 기본적으로 var취급 되게 선언하는 것이 아니라 let 이름 = function(){}으로 하면 중복된 이름을 가진 객체를 만들게 되진 않는다.
          따라서 덮어쓰기까지 방지 하기 위해서는 const까지 붙여주면 같은 이름에 의해 덮어지는 실수를 줄일 수 있다.
            
              
4. constructor(생성자) : 인스턴스를 생성하고 그 참조를 반환하는 특별한 목적의 메서드 
                        메서드에서 this.속성이름 을 이용해서 인스턴스의 속성을 생성할 수 있습니다.
                        일반 메서드에서 속성을 생성하는 경우 메서드 호출을 하지 않으면 속성을 사용할 수 없다.
                        생성자는 인스턴스를 생성하기 위해 호출하는 메서드이기 때문에 인스턴스를 만드려면 반드시 한 번은 호출해야 한다.
                        생성자에서 필요한 속성을 만들면 속성을 만들기 위해서 다른 메서드를 호출하는 번거로움을 없앨 수 있다.
                        JS에서 constructor 라는 속성에 생성자를 만들어서 대입할 수 있다.
                                
                        생성자는 1개만 만들 수 있는 기본적으로 매개변수가 없고 아무일도 하지 않는 생성자가 1개 제공된다.
                        -> 직접 생성자를 만들면 기본으로 제공되던 생성자는 소멸하고 생성자를 호출하는 방법은 new 생성자 이름(매개변수 나열)
                        -> 실제로는 클래스이름.prototype.constructor가 호출 되는 것.

                        getter & setter - 접근자 메서드
      
                        - 인스턴스 안에 존재하는 속성의 데이터를 변경하고 반환하는 메서드
                        - getter는 속성의 데이터를 반환하는 메서드로 일반적으로 매개변수는 없고 속성의 데이터만 반환하는 형태.
                          이름은 get속성이름 으로 만드는데 속성 이름의 첫 글자는 대문자 표기 - camel표기
                          boolean인 경우 get대신에 is~를 사용하기도 한다

                        - setter는 속성의 데이터를 설정하는 메서드로 매개변수는 1개(데이터 전체) 또는 2개(배열이나 객체의 일부 속성을 변경하는 경우 
                          인덱스나 속성의 이름을 매개변수로 추가하는 경우가 있기도 하다.)로 하는 것이 일반적이면 반환하지 않는다.
                          이름은 set속성이름 으로 만든다.

                        - JS에서 getter앞에 get, setter앞에 set을 추가 하면 데이터를 저장하는 속성처럼 사용하는 것이 가능하나 개발자들은 해당 문법을 잘
                          사용하지 않는다.

                        - Static => 메서드 앞에 static을 붙이면 인스턴스가 아니라 클래스가 호출할 수 있는 속성이 된다.
                          static이 붙으면 인스턴스가 호출할 수 없음
                          instance의 메서드 안에서 static메서드 호출은 가능하나 반대로 static메서드 안에서 instance의 메서드 호출은 불가.
                          -> 클래스가 만들어지고 인스턴스가 만들어지기 때문에 아직 만들어지지 않은 instance의 메서드는 사용불가
                          -> 클래스가 만들어지고 인스턴스가 생성된다 -> 인스턴스 메서드 호출 시점에서는 클래스의 내용이 완성된 상태이나 
                             클래스의 메서드를 호출하는 시점에는 인스턴스가 만들어져 있을 수 있기도 하지만 안되어 있을 경우도 있기 때문에 클래스의 메서드에서는
                             인스턴스의 메서드를 호출하는 것은 안된다.
  
5. 상속 : 상위클래스의 모든 것을 하위클래스가 물려받는 것
          기본적으로는 클래스들을 만들다가 중복되는 내용이 나오면 중복되는 내용을 가지고 상위 클래스를 만들고 다른 클래스들에서
          상속을 하는 형태를 취한다.
          따라서, 화살표의 방향을 위에서 아래가 아닌 아래에서 위로 그린다.

          객체 지향에서 상속이라 하지 않고 is a 라고 하며, 하나의 클래스 안에 다른 클래스의 인스턴스가 포함되는 경우는 has a 라고 한다.

          상속을 받는 방법
          - 클래스 선언뒤에 extends 상위클래스 이름

          super
          - 하위 클래스에서 상위클래스의 속성을 호출할 때 상위클래스 instance를 super라고 한다.
          - 하위 클래스의 일반 메서드에서 상위 클래스에 만들어진 메서드를 호출하고자 할 때는 super.메서드이름()의 형태로 호출한다.
          - constructor 안에서 상위 클래스의 constructor를 호출하고자 하는 경우는 super()로 호출. 

          Method Overriding(재정의)
          - 상위 클래스의 메서드와 동일한 모양의 메서드를 하위클래스에서 다시 정의 하는 것으로 기능확장의 목적을 가지고 있다.
          - 상위 클래스의 메서드를 가지고 그대로 사용하는 것이 부족해서 추가하기 위해서 사용.
            -> 새로운 기능을 만들거라면 overriding을 하면 안된다.(기존의 기능을 반드시 사용하고 기능을 추가 할 때만 사용한다.)

6. Iteration : 순차적 처리를 위한 것으로 모든 데이터가 순차적 처리를 할 수 있는 것은 아니고, JS에서는 Iterable프로토콜 Iterator프로토콜을
               준수해야만 순차적으로 처리가 가능하다.
               
               순차적 처리가 가능한 대표적 데이터가 Array(배열)이다.
               순차적 처리가 가능한 데이터에는 Symbol.iterator가 존재해야한다. -> 확인하면 순차적 처리가 가능한지 알 수 있다.
               Symbol.iterator 속성을 추출해서 next 메서드를 호출하면 순차적으로 처리가 가능하다.

               직접 순차적 데이터를 만들고자 할 때, Generator와 Symbol 내장 객체를 이용해야 한다.

 - for ~ of : for ~ in은 객체나 배열의 모든 속성(배열의 경우는 인덱스)을 순차적으로 접근하기 위한 명령문이고,
              for ~ of는 순차처리가 가능한 데이터(순차처리 가능한 객체가 가진 속성의 실제 값)를 순회하는 명령문.(문자열 순회도 가능)
              -> JS에서는 for~in보다 for~of를 사용하는 경우가 많다.

 - Destructuring : 구조 분해 할당 또는 비구조화 할당이라고 한다. 
                   데이터를 나눠서 저장하는 것으로, 다른 언어에서 Tuple에 해당되는 것.

                   배열 : 순서대로 할당되고 마지막 변수에는 이전에 할당한 것들을 제외한 모든 것들이 할당된다.
                   객체(instance) : 변수의 이름과 속성의 이름을 맞춰서 할당한다.
                   
 - Parameter에도 설정가능
 - Spread 연산 & REST Param
   구조분해 할당을 할 때 나머지를 전부 할당하는 연산을 spread 연산이라고 하고 parameter에 적용하면 rest param이라고 함
   할당할 변수 앞에 ...을 붙여주면 된다.

7. Exception Handling(예외처리)

- Error
 - 물리적 err : 잘못된 문법으로 프로그램이 아예 실행되지 않는 상황.
 - 논리적 err : 문법에 맞게 작성했는데 알고리즘을 틀리게 설계해서 잘못된 결과가 나오는 경우

- Exception(예외) : 문법적으로 오류가 없어 실행은 되나 중간에 특수한 상황으로 인해 프로그램을 중단 시키는 경우
                   (Uncatched~...)

- Assertion(단언) : error가 없고 예외가 발생하는 상황이 아니지만 개발자가 강제로 예외를 발생시켜 프로그램을 중단하는 것.
                   <BE에서는 트래픽양이 급증했을 때 DDos 공격으로 간주하고 강제로 종료시킬 때 자주 사용한다.>

- Debugging : 코드를 작게 쪼개서 실행시키면서 논리적 Err이나 예외발생 지점을 찾아내는 것.

- Test : 이전에는 테스트를 개발이 종료되고 이후에 실행하는 경우가 많았다(EX>알파/베타 테스트).
         하지만 현재는 개발을 하면서 테스트를 같이 진행하는 경우가 많다.(TDD_테스트 주도 개발).
         -> 고객의 니즈가 언제 바뀔지 모르고 쏟아지는 많은 CS들을 공부하고 개발하기에는 시간도 많이 걸림
            그래서 공부를 하면서 프로젝트 개발하는 것을 지향(side project_Ex> G-mail도 대표적인 사이드 프로젝트).

- 예외처리 : 예외가 발생했을 때 어떻게 할 것인가를 작성하는 것.
            예외가 발생하더라도 계속해서 프로그램을 실행시키기 위한 것이 서버단에서의 주 목적이다.
            예외를 로깅(기록)하기 위한 것은 개발자 개인이 성장하기 위한 주 목적이다, Ex> 회사에서 그 동안 발생한 예외들을 신입이 공부하는 것.

- 예외처리 기본 구조
  try {
    예외 발생 가능성이있는 코드
  } catch {
    예외 발생했을 시 수행할 코드
  } finally {
    예외 발생 여부 상관없이 수행할코드
  }
  -> finally구문은 생략가능
     예외가 발생하면 예외 객체가 예외처리 변수에 자동으로 대입된다.
     언어에 따라서 catch를 여러개 만들 수 있는 것도 있고 catch를 생략하고 finally만 적어도 되는 경우가 있다.
     JS같은 경우는 catch를 1개만 작성할 수 있고 catch 대신 finally를 사용할 수 있다.
     
     finally에는 대부분 정리 작업을 수행하는 코드를 작성한다.
     -> 정리 작업이란, client-server 간의 양방향 통신에서 client에서 종료할 시 close 요청을 해야 하는데 하지 않을 경우에 발생하는 문제점에
        대해 해결하는 작업을 의미한다.
        예시로 DB에서 10개의 token을 발급하고, 튕겼을 때 반납하도록 처리하지 않으면 DB는 토큰을 반납받지 않은 상태가 되고 실제로 이용하는 
        Client는 없지만 아무도 DB에 접근을 못하게 되는 경우가 생긴다.

- 예외객체 : 예외가 발생했을 때 catch에 전달되는 객체
    
  - message : 예외 발생 이유
  - description : 예외 설명
  - name : 예외 이름
  
- 강제 예외 발생(조건문과 같이 사용하면 assertion이 된다.)
  - throw 예외메시지
  - throw new Error(예외메시지) 

8. Module Programming : 프로그램을 분할해 작성하는 것으로 일반적인 언어에서는 클래스 단위로 분할하는 것이 일반적입니다.
                        함수 단위로 분할하는 경우도, 화면단위로 분할하는 경우도 있다.
                        얼만큼을 하나로 하는가가 가장 어려운 문제이다.

- Export : 현재 모듈의 내용을 내보내서 외부에서 사용가능하도록 하는 기능.
           export 데이터 형태로 내보내서 사용한다.
           또한 export default 데이터로 내보낼 수 있는데 이경우는 명시적으로 1개의 데이터만 내보내고자 할 때 사용한다.
           이와 같이 사용되면 그 코드는 하나의 모듈에 1번만 작성되어야 한다.

 - 각자 내보내기 : export 내보내고자 하는 데이터(값, 함수, 클래스) 나열
 
 - 여러개 묶어 내보내기 : export {내보내고자 하는 데이터 나열}

 - 이름 변경해서 내보내기 : export {원래 이름 as 변경할 이름}

 - 구조 분해 할당을 이용한 내보내기 : exprot{이름 나열} = 객체나 배열 // 배열도 가능하지만 그럴 가능성은 매우 낮음
 
 - 1개만 내보내기 : exprot default 데이터;

- Import : 다른 module에서 export한 내용을 가져와서 사용하기 위한 명령어

 - default로 내보낸 데이터 가져오기 : improt 이름 from "모둘이름";

 - export된 모든 데이터를 하나의 이름으로 가져오기 : import * as from "모듈이름"; 
 
 - export된 데이터 중 일부분 만 겨져오기 : import {이름} from "모듈이름" -> 모듈중에 이름에 해당하는 것만 가져와서 사용

 - export된 이름을 변경해서 사용하는 경우 : import {이름 as 다른이름} from "모듈이름";

9. Built-in Object(내장객체)

 - 종류

  - 일반객체 : JS에서 제공하는 일반적인 객체_브라우저 상관없이 동작.
  
  - BOM(Browser Object Model) : 브라우저에서 제공하는 객체

  - DOM(Document Object Model) : HTML의 body 부분에 만드는 태그들을 사용하기 위한 객체

 - Document : https://www.w3schools.com/jrest/default.asp
              https://devdocs.io/javascript
              에서 지원되는 내장 객체들을 확인해 볼 수 있다.

 - 일반 내장 객체
  
  - Object : JS의 최상위 객체로 JS는 모든 객체가 이 객체를 상속받는다.

  - 객체 생성 방법 : {}와 new Object() 의 형태를 이용해 생성한다.

  - 주요 속성과 메서드
  
   - prototype 속성 : 이 속성에 데이터를 추가하면 모든 객체 데이터를 사용할 수 있다.
   
   - toString 메서드 : 객체를 문자열로 변환하는 메서드로 출력하는 메서드에 객체 이름을 대입하면 자동으로 호출되는 메서드

  - Number 객체 : 숫자와 관련된 객체, 12.265 =? 1.226E + 002
                 객체를 생성할 때, 숫자를 직접 대입해도 되고 new Numver(숫자로 구성된 문자열)
  
  - Math 객체 : java 클래스를 그대로 가져와서 사용한다, 특이 하게도 Math는 멤버가 static이다 -> 클래스라서 인스턴스를 만들 필요 없이 바로 
                접근가능.

  - String : 문자열 클래스
   
   - 생성 : 큰 따옴표나 작은 따옴표 안에 문자열 리터럴을 대입해서 생성할 수 있고 new String(문자열)을 이용해서 생성하는 것이 가능하다.

  
   - 주요 속성 : lenght _ 문자열 길이 반환
   
   - 메서드
     charAt(인덱스) : 인덱스 번째 문자를 반환.
     
     indexOf(문자) : 해당되는 문자를 앞부터 검색 가진 인덱스들을 반환.
                     lastIndexOf() -> 뒤에 부터 검색해서 인덱스 반환, 둘 다 못찾으면 -1반환.
     
     trim() : 문자열의 좌우 공백을 제거.
     
     charCodeAt(인덱스) : 해당 문자열의 코드 반환.
     
     toUpperCase() : 대문자로 변환(toLowerCase는 반대)
     
     split("기준이될 문자열") : 기준이될 문자열 좌/우로 나눠 배열로 만든다.
     
     substring(index...) : 매개 변수가 1개이면 해당 문자열 이후 전부잘라서 반환
                           매개 변수가 2개면 앞은 시작위치, 뒤의 것은 끝위치이거나 개수가 될 수도 있다.
    
   - Tamplate Literal : 문자열 처리를 위한 템플릿
                        문자열과 데이터를 조합해 문자열을 생성하기 위해 추가된 문법.

                        `문자열$(데이터)`: 문자열 안에 데이터를 문자열로 추가해 문자열을 생성한다
                                          해당 구조를 이용하면 중간에 줄 바꿈을 해도 된다.
   
   
   - 문자열 관련 작업중 중요한 것
     문자열의 좌우 공백 제거 문제를 해결하는 것.
     영문 대/소문자 구분을 할지 하지 않을지 적용하는 것. <P.S. 일반적으로 ID는 대소문자를 구별하지 않는다.>

   - 특정한 패턴의 문자나 문자열의 존재가 있는지 확인
     불용어의 사용을 고려해야 한다 -> SQL injection 같은 문제를 고려하는 것.
     -> id/pw 값을 받아 if문을 사용하는 경우 T/F로 판단하게 되면 어떤 식으로든 T로 만들면 되기 때문에 SQL 예약어들을 불용어로 등록해야한다.

   - 한글을 사용할 때, 인코딩 문제를 해결해야 한다.
     
   - Date : 날짜와 관련된 클래스로 Java에서 그대로 가져왔다.

    - 생성 
      new Date() : 현재 날짜 및 시간을 가져온다.
      
      new Date(년, 월, 일, 시, 분, 초, 밀리초) : 입력한 데이터를 가지고 날짜 및 시간을 만들어내는데 월은 -1해서 설정해야 한다.

      new Date(정수) : 정수는 1970 1월 1일 자정(epoch time)에서 지나온 시간을 밀리초 단위로 설정
    
    - 메서드 : 각 단위 별로 가져오고 설정할 수 있는 메서드를 제공하며 현재 설정에 따른 시간을 문자열로 반환해주는
              toGMTString, toLocaleString, toString 메서드를 제공한다.

      getTime() : 1970sus 1월 1일 자정 이후로 지나온 시간을 밀리초 단위로 반환한다.

   - Array(배열 객체) : 다른 언어의 배열과의 차이점은 배열 크기가 가변적이라는 것인데 
                       다른 언어의 Doble Linked List와 유사하다고 생각하면 된다.

    - 생성 방법
      [데이터 나열]
      new Array() : 비어있는 배열 생성
      new Array(데이터 개수) : 데이터 개수만큼 저장할 수 있는 공간을 확보해서 생성
      new Array(데이터 나열) : 데이터를 가지고 생성
      
      -> 비어있는 배열을 생성해서 나중에 더 많은 공간을 차지하게 되었는데 원래 확보한 공간이 부족하다면 전체 데이터를
        추가된 데이터 만큼 저장할 수 있는 공간으로 옮기는 마이그레이션이 발생할 가능성이 있어서 바람직하지 않다.
    
    - 데이터 개수는 lenght라는 속성을 제공한다.

    - 하나 하나의 데이터를 접근할 수 있는 [인덱스]를 제공한다. -> 0 to lenght - 1

    - for-in 을 이용해 모든 인덱스를 접근할 수 있고 for-of를 이용해 모든 데이터에 순차 접근이 가능

P.S.
List : 데이터를 연속적으로 저장하는 것을 List라고 한다.

일반적으로 Array는 입력한 순서대로 연속해서 저장하나, 여기서 연속은 물리적인 연속으로 한 번 만들면 크기가 고정한다.
하지만 JS는 그렇지 않고 대부분의 언어는 그렇게 된다.
[10, 20, 30]은 [| 10 | 20 | 30 |(length)]와 같이 length가 있는 경우가 많다.

하지만 Array List(Vector)는 크기가 변할 수 있는 배열로 위의 배열이 [10 | 20 | 30 | | | ~~...| |...]처럼 뒤에
더 많은 공간을 확보한다, 이때 중간에 데이터를 중간에 삽입하면 해당 자리에 있던 데이터 부터 모두 뒤로 미루거나 삭제할 때는
해당 자리에 있던 데이터를 삭제하고 그 뒤의 데이터 들을 모드 앞의 인덱스로 당겨오는 작업을하 한다.

Linked List는 물리적인 연속이 아니라 논리적인 연속을 같는 데이터로 하나의 데이터가 다음에 올 데이터의 참조를 
가지고 있다.
따라서, Linked List는 데이터들 사이에 추가/삭제 할 때 Array List같은 마이그레이션이 발생하지 않는다.
보통 PC에서 파일을 삭제할 때 위와 같이 해당 파일 데이터에 찾아갈 방법(참조)를 삭제하게 하는 것.
-> 실제로 파일을 삭제하는 것은 오래 걸린다.

Double Linked List는 앞선 Linked List에 본인의 이전 데이터의 참조도 가지고 있는 구조.
이렇게 짜여진 논리적 연속의 앞과 끝에는 Start Of File, End of File의 Head를 갖고 있다.

    - 메서드
      concat(배열): 배열 결합
      reverse() : JS_ArrayOBJ 는 Doble Linked List와 비슷한데 Reverse는 해당 배열 객체가 가지고 있는 
                  SOF/EOF를 바꾸는 것으로 실제로 물리적인 데이터들이 Reversing 되는 것이 아니다.
      slice(strat, end)

      sort([정렬을 위한 함수]) : 데이터 정렬
                  
      pop(): 마지막에 있는 데이터를 삭제하고 반환
      push(data): data를 마지막에 추가
      shift(): 첫번째 데이터를 삭제하고 반환
      unshift(data): data를 맨 앞에 추가

      remove(인덱스) : 인덱스 번째 데이터를 삭제

      indexOf, lastIndexOf
      toString(): 배열을 문자열로 만들어서 반환
      join(구분기호): 배열의 각 요소를 구분기호를 추가하면서 하나의 문자열로 만들어 반환

      정렬(sorting) : 데이터를 순서대로 나열하는 것

        방향에 따른 종류
          ascending(오름차순): 작은 것에서 큰 순서로 나열하는 것으로 기본값이다.
          descending(내림차순): 큰 것에서 작은 순서로 나열하는 것.
        
        알고리즘에 따른 종류_신입으로 면접을 볼 때는 quick sort를 구현하고 설명할 수 있는 것이 중요.
          selection(선택)
          buble
          insertion(삽입)
          heap
          quick
          radix
          merge
          shell
        
        JS에서 sort()는 숫자 데이터 경우 문자열로 변환해 정렬을 수행한다.
        다른 방법으로 정렬하고자 할 때 sort 함수에 매개변수가 2개이고 정수를 반환하는 함수를 대입해야 한다.
        2개 매개변수는 배열에 있는 2개의 데이터를 번갈아가면서 대입하는데 이 때 양수를 반환하면 앞의 데이터가 
        크다고 판단해서 위치를 변경하고 0을 반환하면 같다고 판단해 위치를 변경하지 않고 음수를 반환하면 앞의 데이터가
        작다고 판단해서 위치를 변경하지 않는다.
        -> 이 원리는 거의 모든 프로그래밍에서 동일하다.

        배열에 추가된 함수 -> 아래 함수들은 함수를 매개변수로 받는다.
        
          forEach() : 매개변수가 1개이고 반환값이 없는 함수를 매개변수로 받아서 모든 요소를 매개변수에 대입해서
                      함수를 호출한다.
        
          map(): 매개변수가 1개이고 반환값이 있는 함수를 매개변수로 받아서 모든 요소를 매개변수로 대입해서 함수를 호출한 
                후 그 결과를 가지고 다시 배열을 만들어서 반환한다.
                -> 배열에 어떤 연산을 가해서 새로운 배열을 만들고자 할 때 사용한다.
        
          filter(): 매개변수가 1개이고 Boolean을 반환하는 함수를 매개변수로 받아서 배열의 모든 요소를 매개변수로 대입해서 함수를 
                    호출한 후 true를 반환한 데이터만 모아서 배열로 반환한다.

          every(): 매개변수가 1개이고 Boolean을 반환하는 함수를 매개변수로 받아 배열의 모든 요소를 매개변수로 대입해 함수를
                  호출한 후 모든 데이터가 True를 반환하는지 확인해서 Boolean으로 반환한다.

          some(): 매개변수가 1개이고 boolean을 반환하는 함수를 매개변수로 받아 배열의 모든 요소를 매개변수로 대입해서 함수를
                  호출한 후 1개의 데이터라도 true를 반환하는지 확인해서 boolean값으로 반환한다.

        JAVA 에서는 이를 위해서 lamda와 Stream 이라는 새로운 API를 1.8버전에 추가했음 -> 그만큼 중요하다.
    
  - JSON 객체 : JavaScript Object Notation의 약자로 자바스크립트의 객체 표현법의 문자열로 만드는 것
                현재 통신 방식에서 가장 많이 사용되는 데이터 포맷으로 Python도 동일하게 사용한다.

    객체 : {"속성이름" : 데이터, ...}
    배열 : [데이터 나열]

    JSON.parse(json 문자열): json 문자열을 자바스크립트 데이터로 변경해서 반환한다. 서버에서 데이터를 받아온
                              경우에 사용한다.
      
    JSON.stringify(자바스크립트데이터): 데이터를 json 문자열로 변환한다. 서버에게 데이터를 전송할 때 사용한다.
    

연습문제 <염기서열 분석 예제 원리와 같다.>
var str = "CGCCGDKSKDGCCGCCGDKDGCCGDS"
와 같은 문자열에서 GCCG를 찾아서 첫글자의 위치를 전부 출력하시오
한번 GCCG를 구성한 알파벳은 다시 사용하면 안된다.

***String 을 잘 해야하는 이유***

User <--> clinet(FE)  -------> (Request) -----> Server(BE){ connect Server(연결만) <---> Application Server(일) <---> Data Server(저장) }
                      <------- (Response) <----

-> Req/Res 사이에 통신으로 Trafic발생(비용)

-> DataServer은 File/Data Server로 나뉜다.

-> DataServer은 RDBMS/NoSQL/분산파일 로 다시 나뉜다.

-> Server단 전체는 WebServer/SoketServer로 나뉘는데 Soket 서버가 비교적 성능이 좋고 Web서버가 사용하기에는 편리하다.

-> Client단은 Browser/Application으로 나뉘며 브라우저 서버는 웹서버를 주로 이용하고, 애플리케이션은 웹/소켓 서버 둘다 주로 이용.

-> 하지만 Application 또한 Browser 안에 담을 수 있도록 하는 추세이다.

-> client에서 Req/Res 의 Validation check(검사)를 진행하는 것이 Trafic을 감소시키는 방법, 물론 Connect 서버와 Application 서버 사이에도 진행

-> 그렇다면 Client단에서 무엇을 검사하나? -> 입력하는 것이 문자/파일 밖에 없다.

-> 파일은 존재여부, 크기, 종류 등을 확인/검사 하면 비교적 간단하게 해결가능

-> 문자는 String으로 문자열의 패턴 등을 검사하고, RegExp(정규식)으로 검사한다. <Connect/Application Server 사이도 마찬가지.>

-> 이때, String 으로 제어할 수 있는 것이 굉장히 많고, RegExp도 String을 조금 더 편하게 쓰는 것(String이 RegExp대체 가능).

-> Server에서는 String Stream / Buffer 을 언어에 따라 지원하지 않을 수 있다.

-> charAt(), indexOf()만 사용해서 하는 것을 추천하는 이유.

-> 오늘 RegExp를 하면 id/pw 등이 가진 특이 속성에 대해 참/거짓 판단하는 거 연습 ---> ex> 특수기호, 숫자, 대소문자 등의 패턴

-> 또한 위의 전 과정을 클라우드에 올려 배포하는 것이 중요하다.

-> 여기 까지가 Dev이고 이후 운영과 CI/CD를 합치면 DevOps라고 생각하면 된다.

<연습문제> 13자리 문자열을 만들고 뒤의 6자리는 별로 보여주기
<MSA_책 -> 서버 이중화가 아니라 서비스마다의 서버를 분산하는 것>

  - RegExp(정규 표현식)객체

    - 정규 표현식
      문자열의 패턴을 정의하기 위한 객체로 Perl에서 처음 사용되었는데 지금은 거의 모든 언어에서 제공하고 언어차원
      에서 제공하지 않으면 외부 라이브러리를 통해서 제공한다.
      일반적으로 문자열의 패턴을 찾거나 유효성 검사를 위해 사용된다.

    - 장점 : 복잡한 코드를 줄여서 표현할 수 있다.
    - 단점 : 가독성이 떨어진다.

    - 구성 
      Pattern
      Modifier(한정자) : 제약조건을 설정.

    - 객체 생성 방식 -> 패턴자리에 비교되는 숫자나 문자열 자체가 올 수 있지만 메타문자, 수량문자, 앵커문자 등을
                      이용해 정규식을 새워서 대입할 수 도 있다.
                      이러한 정규식은 구글링을 통해 이미 만들어 놓은것을 가져오는 것이 효율적이나 학습할 때는 본인이 하는 것을 지향
                      Ex> email, id, 주민번호 등의 유효성을 검사하는 것.
      1) new RegExp(Pattern, Modifier)

      2) /Pattern/Modifier

    - 함수
      test(문자열): 문자열에 정규표현식 패턴이 존재하는지 확인

      exec(문자열): 정규 표현식 문자열을 반환한다.

    - String 관련 정규 표현식 메서드
      
      match(정규표현식): 정규표현식과 일치하는 부분을 반환한다.

      replace(정규표현식): 정규표현식과 일치하는 부분의 인덱스를 반환한다.

      search(정규 표현식): 정규표현식과 일치하는 부분의 인덱스를 반환한다.

      split(정규 표현식): 정규 표현식과 일치하는 부분을 찾아서 잘라낸 다음 배열로 반환한다.

    - 한정자
      
      g : 전체영역에서 비교

      i : 대소문자 구분없이 비교

      m : 여러 줄에서 비교

    - 앵커문자
      
      ^패턴: 패턴으로 시작하는
      패턴$: 패턴으로 끝나는

    - 메타문자
      . : 아무글자
      
      [문자나열] : 문장중 1개

      [^문자] : 문자를 제외하고

      [시작-끝] : 시작에서 끝에 포함되는 // Ex> 영문소문자[a-z], 영문 대소문자[A-Za-z], 한글[가-힣]

      \d: 숫자, \D: 숫자가 아닌

      \w: 단어, \W: 단어가 아닌

      \s: 공백문자, \s: 공백문자가 아닌

    - 수량 문자

      +: 1개 이상
      
      *: 0개 이상

      ?: 0개 또는 1개

      {횟수}: 횟수

      {최소횟수, 최대횟수}: 최소에서 최대사이

      {최소횟수,}: 최소횟수 이상

      {, 최대횟수}: 최대횟수 이하
  
  - Set : *여러개의 데이터를 중복없이 저장하는 자료구조 데이터를 가지고 KEY를 만들어서 저장한다.*
          이 때, 해싱을 수행해서 Key를 만들어낸다, 해싱은 데이터를 가지고 새로운 데이터를 만들어 내는 것이다.
          이렇게 만들어진 코드를 HashCode라고 하며 데이터가 같으면 HashCode가 일치한다.
          HashCode가 같다고 해서 데이터가 같지는 않습니다, 확률적으로 아주 드물다.
          HashCode를 가지고 원본 데이터를 찾는 것도 아주 어렵다.
  
    - 함수
      add, has, keys, valuss, delete, clear 등

    - 
** JS의 OOP객체 지향 프로그래밍, ES5까지는 클래스의 개념이 없어서 OOP의 개념이 아님 
   객체 기반 언어 ECMA 2015에서 클래스 개념이 도입됨

1. 객체지향의 3대 특징
  - Encapsulation(캡슐화) : 불필요한 부분을 숨기고 만드는 것
                            클래스를 만드는 것과 인스턴스를 만드는 것 그리고 지정자률 학습
    
  - Inheritance(상속) : 하위 클래스가 상위 클래스의 모든 것을 물려 받는 것

  - polymorphsim(다형성) : 동일한 메시지에 대해 다르게 반응하는 성질
                           동일은 코드가 호출하는 객체에 따라 다른 메서드를 호출하는 성질
                           상속과 오버라이딩(가끔은 오버라이딩이 아니라 구현)으로 구현됨

2. 객체(Object) : 데이터를 저장할 수 있는 속성(variable - property)과 기능을 수행하는 메서드(function - method)
                   모아 놓은 것.

                  종류
                  - 사용자 정의 객체 : 개발자가 필요에 의해서 생성하는 것
                                     
                                     생성
                                     - var(let or const) 이름 = {"속성이름" : 데이터, "메서드이름" : 메서드 코드..}
                                     - var(let or const) 이름 = new 생성자(매개변수 나열)
                                     
                                     내부 요소 호출
                                     - 이름.속성이름
                                     - 이름.메서드이름(매개변수)
                                     -> .이름 대신에 [속성이름]으로 속성 호출이 가능한데 이 때 문자열 형태로 입력해야 한다.
                                        var obj = {"name" : "adam"}; 
                                        obj.name == obj["name"]
                                     - 내부 속성은 중복해서 만들어지지 않으므로 동일한 이름에 2번 삽입하면 내용이 없어지고 새로운 내용으로 변경된다. 
                                     - for(임시변수 in 객체이름){수행할 내용} : 객체의 모든 속성의 이름을 임시변수에 문자열 형태로 대입하고 {}안의 내용을 반복수행
                                     - "속성이름" in 객체 : 속성이 객체에 존재하는지 여부를 판단해서 Boolean값으로 반환
                                     
                                     with 블럭
                                     - with(객체이름){ // 해당 블록 내에서는 객체이름 생략가능 }
                                     
                                     속성 추가 및 수정
                                     - 객체이름.속성이름 = 데이터 또는 함수; -> 존재하는 속성이면 수정이고 존재하지 않는 속성이면 해당 속성 추가
                                    
                                     속성 삭제
                                     - delete(객체이름.속성이름)
                                     
                                     this
                                     - 객체 안에 존재하는 메서드에 존재하는 숨겨진 매개변수
                                     - 객체 안에 만들어진 메서드에서는 this라는 변수를 사용할 수 있는데 이 this는 객체를 참조한다.
                                     - 객체 안에 만들어진 메서드에서 객체의 속성을 이용할 때는 this.속성이름 의 형태로 사용해야한다.
                                     - this를 붙이지 않으면 메서드 안에서 이름을 찾아야한다.
                                     - 화살표 함수에서는 this를 사용할 수 없기 때문에 위의 방법으로 찾아야함.

P.S. JS에서는 리터럴/상수/함수/클래스 등의 객체들이 정적 Heap에 올라가고 속성의 값인 인스턴스(데이터, 메서드)는 동적인 Heap공간에 들어가 있어서 찾아갈 방법이 없다.
     찾아 올 수 없다.
     JS에서 클래스나 객체에서 메서드를 생성 했을 때, 데이터나 메서드는 객체에 참조되어 진다, 이때 그 참조를 가리킬 수 있는 this나 super라는 도구가 있는 것이다.
     
     함수와 메서드의 차이는 호출자가 있으면 메서드 없으면 함수라고 보통한다.
     함수는 숨겨진 메서드가 없고, 있으면 숨겨진 매게변수(this, super)가 있다.
                                     
                                     constructor(생성자)
                                     - 생성자는 객체를 생성해서 메모리 할당을 하고 그 참조를 반환하는 함수
                                     - 일반 함수를 만드는 것과 동일한 방법으로 만드는데 객체를 생성하고자 하면 내부에서 this를 이용해서 필요한 속성과
                                       메서드를 정의하면 된다.
                                     - 생성자 호출 : new 생성자이름(매개변수)
                                     - 생성자(클래스)를 만드는 이유는 동일한 속성을 갖는 객체를 여러개 생성해야 하는 경우입니다.

                   - 내장 객체 : JS에서 제공하는 객체 - API(Application Programing Interface) 나 SDK(Software Development Kit)
                                라고 함
                   - 3rd Party객체 : 다른 개발자나 회사가 제공 (Library, Framework : Solution)
                                   라이브러리는 제 3자가 많이 쓰는 기능/틀을 제공하는 정도
                                   프레임워크는 프로젝트 하나를 만들 정도로 제공하는 정도
                                   솔루션은 학사정보 시스템과 같은 것을 만드는데 어느정도 핵심 틀이 있는 사람
    
3. Class : 유사한 모양의 객체를 만들기 위한 템플릿
           생성자를 이용해서도 생성이 가능하지만 생성자를 이용하게 되면 모든 멤버를 생성자 안에서 만들어야 하기 때문에 객체가 가져야하는
           메서드가 많아지면 코드의 가독성이 떨어진다.
           ECMA2015(=ES6)에서 Class문법을 추가 시켰다.

           선언
           - 기본적인 방법
             class 클래스 이름 {
                클래스 내용
              } 
                
          상속을 받는 경우
           class 클래스이름 extends 상위클래스 이름{
                    클래스 내용
            }
                
          표현식 이용
          let 이름 = class{클래스 내용}
          let 이름 = class 내부에서 사용할 이름{클래스 내용}

          클래스를 이용한 객체 생성
          - 클래스를 이용해서 생성된 객체를 instance라고 한다.

          - var i = 10, var j = new ?() -> i와 j 모두 객체에 해당되지만 j는 인스턴스이다. 
                  큰 차이는 new를 이용하면 동적 heap 영역에 생성되고, 단순 선언된 경우 정적 heap영역에 생성되는 것.
                
          - 클래스의 생성자는 클래스 이름과 동일하게 만들어지기 때문에 생성자 이름 대신에 클래스 이름을 기재해도 된다.
            var[let||const] 이름 = new 생성자이름(매개변수)에서 엄밀히 말하면 = 이후에 오는 것이 인스턴스에 해당되나 구별하진 않는다.
            new 연산자는 생성자를 호출해서 인스턴스를 동적인 heap 영역에 만들고 그 참조를 반환하는 연산자이다.

          클래스 안에 멤버 속성 만들기
          - 메서드 안에서 this와 이름을 만들면 인스턴스의 속성이 되는 것.

          JS에서 Class는 정적이지 않다. 즉, JS에서는 Class의 내용을 수정할 수 있다.(다른언어는 힘들다)
          기본적으로 Class는 생성되면 정적이다, JAVA 또한 마차가지로 Class는 한 번 생성되면 정적이다.
                
          JS는 Class가 prototype이라는 내부 객체를 이용해서 모든 속성을 저장하는데, prototype이 객체이므로 확장이 가능하디.
          클래스를 선언할 때는 없었는데 나중에 추가하거나 변경하고자 하면 클래스이름.prototype.속성이름 = 내용 과 같은 형태로 이미 선언된
          클래스에 동적으로 속성을 추가할 수 있다.
                
          이름
          - JS에서 변수, 함수, class가 모두 동일한 Lv로 기존의 이름에 값이 저장되어 있는데, 함수를 대입하면 기존 값은 사라지고 함수의 내용이
            저장된다.
                
          - 하나의 이름에 한 가지만 저장 가능 -> 중복 정의(OverLoading)이 안된다.
                  
          기존에 했던 언어들은 매개변수가 있는, 매개변수가 없는 동일한 이름의 함수에 대해 각 해당 하는 경우에만 적용되었다.(오버로딩)
          하지만 JS는 무조건 이름에 해당되는 것에 적용되기 때문에 오버로딩 되어지지 않고 그냥 함수를 덮어써버린다.
          즉, 같은 이름으로 함수f(), 함수f(n), 클래스f() 순으로 선언하면 결국 f는 클래스가 되어버린다.
          이때, 기본적으로 var취급 되게 선언하는 것이 아니라 let 이름 = function(){}으로 하면 중복된 이름을 가진 객체를 만들게 되진 않는다.
          따라서 덮어쓰기까지 방지 하기 위해서는 const까지 붙여주면 같은 이름에 의해 덮어지는 실수를 줄일 수 있다.
            
              
4. constructor(생성자) : 인스턴스를 생성하고 그 참조를 반환하는 특별한 목적의 메서드 
                        메서드에서 this.속성이름 을 이용해서 인스턴스의 속성을 생성할 수 있습니다.
                        일반 메서드에서 속성을 생성하는 경우 메서드 호출을 하지 않으면 속성을 사용할 수 없다.
                        생성자는 인스턴스를 생성하기 위해 호출하는 메서드이기 때문에 인스턴스를 만드려면 반드시 한 번은 호출해야 한다.
                        생성자에서 필요한 속성을 만들면 속성을 만들기 위해서 다른 메서드를 호출하는 번거로움을 없앨 수 있다.
                        JS에서 constructor 라는 속성에 생성자를 만들어서 대입할 수 있다.
                                
                        생성자는 1개만 만들 수 있는 기본적으로 매개변수가 없고 아무일도 하지 않는 생성자가 1개 제공된다.
                        -> 직접 생성자를 만들면 기본으로 제공되던 생성자는 소멸하고 생성자를 호출하는 방법은 new 생성자 이름(매개변수 나열)
                        -> 실제로는 클래스이름.prototype.constructor가 호출 되는 것.

                        getter & setter - 접근자 메서드
      
                        - 인스턴스 안에 존재하는 속성의 데이터를 변경하고 반환하는 메서드
                        - getter는 속성의 데이터를 반환하는 메서드로 일반적으로 매개변수는 없고 속성의 데이터만 반환하는 형태.
                          이름은 get속성이름 으로 만드는데 속성 이름의 첫 글자는 대문자 표기 - camel표기
                          boolean인 경우 get대신에 is~를 사용하기도 한다

                        - setter는 속성의 데이터를 설정하는 메서드로 매개변수는 1개(데이터 전체) 또는 2개(배열이나 객체의 일부 속성을 변경하는 경우 
                          인덱스나 속성의 이름을 매개변수로 추가하는 경우가 있기도 하다.)로 하는 것이 일반적이면 반환하지 않는다.
                          이름은 set속성이름 으로 만든다.

                        - JS에서 getter앞에 get, setter앞에 set을 추가 하면 데이터를 저장하는 속성처럼 사용하는 것이 가능하나 개발자들은 해당 문법을 잘
                          사용하지 않는다.

                        - Static => 메서드 앞에 static을 붙이면 인스턴스가 아니라 클래스가 호출할 수 있는 속성이 된다.
                          static이 붙으면 인스턴스가 호출할 수 없음
                          instance의 메서드 안에서 static메서드 호출은 가능하나 반대로 static메서드 안에서 instance의 메서드 호출은 불가.
                          -> 클래스가 만들어지고 인스턴스가 만들어지기 때문에 아직 만들어지지 않은 instance의 메서드는 사용불가
                          -> 클래스가 만들어지고 인스턴스가 생성된다 -> 인스턴스 메서드 호출 시점에서는 클래스의 내용이 완성된 상태이나 
                             클래스의 메서드를 호출하는 시점에는 인스턴스가 만들어져 있을 수 있기도 하지만 안되어 있을 경우도 있기 때문에 클래스의 메서드에서는
                             인스턴스의 메서드를 호출하는 것은 안된다.
  
5. 상속 : 상위클래스의 모든 것을 하위클래스가 물려받는 것
          기본적으로는 클래스들을 만들다가 중복되는 내용이 나오면 중복되는 내용을 가지고 상위 클래스를 만들고 다른 클래스들에서
          상속을 하는 형태를 취한다.
          따라서, 화살표의 방향을 위에서 아래가 아닌 아래에서 위로 그린다.

          객체 지향에서 상속이라 하지 않고 is a 라고 하며, 하나의 클래스 안에 다른 클래스의 인스턴스가 포함되는 경우는 has a 라고 한다.

          상속을 받는 방법
          - 클래스 선언뒤에 extends 상위클래스 이름

          super
          - 하위 클래스에서 상위클래스의 속성을 호출할 때 상위클래스 instance를 super라고 한다.
          - 하위 클래스의 일반 메서드에서 상위 클래스에 만들어진 메서드를 호출하고자 할 때는 super.메서드이름()의 형태로 호출한다.
          - constructor 안에서 상위 클래스의 constructor를 호출하고자 하는 경우는 super()로 호출. 

          Method Overriding(재정의)
          - 상위 클래스의 메서드와 동일한 모양의 메서드를 하위클래스에서 다시 정의 하는 것으로 기능확장의 목적을 가지고 있다.
          - 상위 클래스의 메서드를 가지고 그대로 사용하는 것이 부족해서 추가하기 위해서 사용.
            -> 새로운 기능을 만들거라면 overriding을 하면 안된다.(기존의 기능을 반드시 사용하고 기능을 추가 할 때만 사용한다.)

6. Iteration : 순차적 처리를 위한 것으로 모든 데이터가 순차적 처리를 할 수 있는 것은 아니고, JS에서는 Iterable프로토콜 Iterator프로토콜을
               준수해야만 순차적으로 처리가 가능하다.
               
               순차적 처리가 가능한 대표적 데이터가 Array(배열)이다.
               순차적 처리가 가능한 데이터에는 Symbol.iterator가 존재해야한다. -> 확인하면 순차적 처리가 가능한지 알 수 있다.
               Symbol.iterator 속성을 추출해서 next 메서드를 호출하면 순차적으로 처리가 가능하다.

               직접 순차적 데이터를 만들고자 할 때, Generator와 Symbol 내장 객체를 이용해야 한다.

 - for ~ of : for ~ in은 객체나 배열의 모든 속성(배열의 경우는 인덱스)을 순차적으로 접근하기 위한 명령문이고,
              for ~ of는 순차처리가 가능한 데이터(순차처리 가능한 객체가 가진 속성의 실제 값)를 순회하는 명령문.(문자열 순회도 가능)
              -> JS에서는 for~in보다 for~of를 사용하는 경우가 많다.

 - Destructuring : 구조 분해 할당 또는 비구조화 할당이라고 한다. 
                   데이터를 나눠서 저장하는 것으로, 다른 언어에서 Tuple에 해당되는 것.

                   배열 : 순서대로 할당되고 마지막 변수에는 이전에 할당한 것들을 제외한 모든 것들이 할당된다.
                   객체(instance) : 변수의 이름과 속성의 이름을 맞춰서 할당한다.
                   
 - Parameter에도 설정가능
 - Spread 연산 & REST Param
   구조분해 할당을 할 때 나머지를 전부 할당하는 연산을 spread 연산이라고 하고 parameter에 적용하면 rest param이라고 함
   할당할 변수 앞에 ...을 붙여주면 된다.

7. Exception Handling(예외처리)

- Error
 - 물리적 err : 잘못된 문법으로 프로그램이 아예 실행되지 않는 상황.
 - 논리적 err : 문법에 맞게 작성했는데 알고리즘을 틀리게 설계해서 잘못된 결과가 나오는 경우

- Exception(예외) : 문법적으로 오류가 없어 실행은 되나 중간에 특수한 상황으로 인해 프로그램을 중단 시키는 경우
                   (Uncatched~...)

- Assertion(단언) : error가 없고 예외가 발생하는 상황이 아니지만 개발자가 강제로 예외를 발생시켜 프로그램을 중단하는 것.
                   <BE에서는 트래픽양이 급증했을 때 DDos 공격으로 간주하고 강제로 종료시킬 때 자주 사용한다.>

- Debugging : 코드를 작게 쪼개서 실행시키면서 논리적 Err이나 예외발생 지점을 찾아내는 것.

- Test : 이전에는 테스트를 개발이 종료되고 이후에 실행하는 경우가 많았다(EX>알파/베타 테스트).
         하지만 현재는 개발을 하면서 테스트를 같이 진행하는 경우가 많다.(TDD_테스트 주도 개발).
         -> 고객의 니즈가 언제 바뀔지 모르고 쏟아지는 많은 CS들을 공부하고 개발하기에는 시간도 많이 걸림
            그래서 공부를 하면서 프로젝트 개발하는 것을 지향(side project_Ex> G-mail도 대표적인 사이드 프로젝트).

- 예외처리 : 예외가 발생했을 때 어떻게 할 것인가를 작성하는 것.
            예외가 발생하더라도 계속해서 프로그램을 실행시키기 위한 것이 서버단에서의 주 목적이다.
            예외를 로깅(기록)하기 위한 것은 개발자 개인이 성장하기 위한 주 목적이다, Ex> 회사에서 그 동안 발생한 예외들을 신입이 공부하는 것.

- 예외처리 기본 구조
  try {
    예외 발생 가능성이있는 코드
  } catch {
    예외 발생했을 시 수행할 코드
  } finally {
    예외 발생 여부 상관없이 수행할코드
  }
  -> finally구문은 생략가능
     예외가 발생하면 예외 객체가 예외처리 변수에 자동으로 대입된다.
     언어에 따라서 catch를 여러개 만들 수 있는 것도 있고 catch를 생략하고 finally만 적어도 되는 경우가 있다.
     JS같은 경우는 catch를 1개만 작성할 수 있고 catch 대신 finally를 사용할 수 있다.
     
     finally에는 대부분 정리 작업을 수행하는 코드를 작성한다.
     -> 정리 작업이란, client-server 간의 양방향 통신에서 client에서 종료할 시 close 요청을 해야 하는데 하지 않을 경우에 발생하는 문제점에
        대해 해결하는 작업을 의미한다.
        예시로 DB에서 10개의 token을 발급하고, 튕겼을 때 반납하도록 처리하지 않으면 DB는 토큰을 반납받지 않은 상태가 되고 실제로 이용하는 
        Client는 없지만 아무도 DB에 접근을 못하게 되는 경우가 생긴다.

- 예외객체 : 예외가 발생했을 때 catch에 전달되는 객체
    
  - message : 예외 발생 이유
  - description : 예외 설명
  - name : 예외 이름
  
- 강제 예외 발생(조건문과 같이 사용하면 assertion이 된다.)
  - throw 예외메시지
  - throw new Error(예외메시지) 

8. Module Programming : 프로그램을 분할해 작성하는 것으로 일반적인 언어에서는 클래스 단위로 분할하는 것이 일반적입니다.
                        함수 단위로 분할하는 경우도, 화면단위로 분할하는 경우도 있다.
                        얼만큼을 하나로 하는가가 가장 어려운 문제이다.

- Export : 현재 모듈의 내용을 내보내서 외부에서 사용가능하도록 하는 기능.
           export 데이터 형태로 내보내서 사용한다.
           또한 export default 데이터로 내보낼 수 있는데 이경우는 명시적으로 1개의 데이터만 내보내고자 할 때 사용한다.
           이와 같이 사용되면 그 코드는 하나의 모듈에 1번만 작성되어야 한다.

 - 각자 내보내기 : export 내보내고자 하는 데이터(값, 함수, 클래스) 나열
 
 - 여러개 묶어 내보내기 : export {내보내고자 하는 데이터 나열}

 - 이름 변경해서 내보내기 : export {원래 이름 as 변경할 이름}

 - 구조 분해 할당을 이용한 내보내기 : exprot{이름 나열} = 객체나 배열 // 배열도 가능하지만 그럴 가능성은 매우 낮음
 
 - 1개만 내보내기 : exprot default 데이터;

- Import : 다른 module에서 export한 내용을 가져와서 사용하기 위한 명령어

 - default로 내보낸 데이터 가져오기 : improt 이름 from "모둘이름";

 - export된 모든 데이터를 하나의 이름으로 가져오기 : import * as from "모듈이름"; 
 
 - export된 데이터 중 일부분 만 겨져오기 : import {이름} from "모듈이름" -> 모듈중에 이름에 해당하는 것만 가져와서 사용

 - export된 이름을 변경해서 사용하는 경우 : import {이름 as 다른이름} from "모듈이름";

9. Built-in Object(내장객체)

 - 종류
  - 일반객체 : JS에서 제공하는 일반적인 객체_브라우저 상관없이 동작.
  
  - BOM(Browser Object Model) : 브라우저에서 제공하는 객체

  - DOM(Document Object Model) : HTML의 body 부분에 만드는 태그들을 사용하기 위한 객체

 - Document : https://www.w3schools.com/jrest/default.asp
              https://devdocs.io/javascript
              에서 지원되는 내장 객체들을 확인해 볼 수 있다.

 - 일반 내장 객체
  
  - Object : JS의 최상위 객체로 JS는 모든 객체가 이 객체를 상속받는다.

  - 객체 생성 방법 : {}와 new Object() 의 형태를 이용해 생성한다.

  - 주요 속성과 메서드
  
   - prototype 속성 : 이 속성에 데이터를 추가하면 모든 객체 데이터를 사용할 수 있다.
   
   - toString 메서드 : 객체를 문자열로 변환하는 메서드로 출력하는 메서드에 객체 이름을 대입하면 자동으로 호출되는 메서드

  - Number 객체 : 숫자와 관련된 객체, 12.265 =? 1.226E + 002
                 객체를 생성할 때, 숫자를 직접 대입해도 되고 new Numver(숫자로 구성된 문자열)
  
  - Math 객체 : java 클래스를 그대로 가져와서 사용한다, 특이 하게도 Math는 멤버가 static이다 -> 클래스라서 인스턴스를 만들 필요 없이 바로 
                접근가능.

  - String : 문자열 클래스
   
   - 생성 : 큰 따옴표나 작은 따옴표 안에 문자열 리터럴을 대입해서 생성할 수 있고 new String(문자열)을 이용해서 생성하는 것이 가능하다.

   - lenght 속성 : 문자열 길이 반환
   - charAt(인덱스) : 인덱스 번째 문자를 반환
   
   - 문자열 관련 작업중 중요한 것
     문자열의 좌우 공백 제거 문제를 해결하는 것.
     영문 대/소문자 구분을 할지 하지 않을지 적용하는 것. <P.S. 일반적으로 ID는 대소문자를 구별하지 않는다.>

   - 특정한 패턴의 문자나 문자열의 존재가 있는지 확인
     불용어의 사용을 고려해야 한다 -> SQL injection 같은 문제를 고려하는 것.
     -> id/pw 값을 받아 if문을 사용하는 경우 T/F로 판단하게 되면 어떤 식으로든 T로 만들면 되기 때문에 SQL 예약어들을 불용어로 등록해야한다.

   - 한글을 사용할 때, 인코딩 문제를 해결해야 한다.
     
연습문제 <염기서열 분석 예제 원리와 같다.>
var str = "CGCCGDKSKDGCCGCCGDKDGCCGDS"
와 같은 문자열에서 GCCG를 찾아서 첫글자의 위치를 전부 출력하시오
한번 GCCG를 구성한 알파벳은 다시 사용하면 안된다.
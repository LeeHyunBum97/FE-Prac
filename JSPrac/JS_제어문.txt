제어문 : 기본적인 명령의 흐름은 왼쪽에서 오른쪽으로, 위에서 아래로 흐른다.
         이런 명령의 흐름을 변경하는 명령어가 제어문에 해당된다.

1. 분기문 : 조건이나 값에 따라 다른 문장을 수행하는 것과

 - if문
   if(표현식){
        표현식이 Truthy일 때 수행할 내용
   } else if {
        앞의 표현식이 Fasly이고 현재 표현식이 Truthy일 때 수행할 내용
   } else {
        앞의 모든 식이 Falsy일 때 수행할 내용
   }
-> else if 는 0개 이상 여러번 작성가능하고 else는 생략하거나 1번만 작성해야 한다.
   if와 else if, else는 별도의 블록으로 처리되어야 하고 가장 위의 표현식이 T라면 아래 표현식은 확인하지 않는다.
   그러므로 항상 분기문 사용시 가장 T가 많은 경우를 가장 윗줄의 표현식(조건문)을 삽입해 효율을 올리고 늘 주석으로 이를 알린다
   feat(코딩테스트)_전체를 못해도 중간까지 하는게 이득


 - switch문 : 값에 의한 분기
   switch(표현식){
        case x : 
            표현식이 x인 경우에 수행할 내용
            break;
        
        case y : 
            표현식이 y인 경우에 수행할 내용
            break;
        ....
        default :
            표현식이 x, y, .... 앞의 어디에도 해당되지 않을 경우 수행할 내용
            break;
   }
   -> 각 case당 break;없을 시 break를 만날 때까지 모든 case에 대한 수행을 하게된다, default 키워드 문 자체와 그 안의 break는 생략가능
      값에 자리에는 반드시 값이 아닌 또 다른 표현식이 와도 상관없다.
      case문은 여러개가 올 수 있지만, 생략불가
      switch(true){}로 작성하고 내부 case문에 Boolean표현식을 작성해 사용하는 경우도 있음


2. 반복문(Loop) : for가 while의 작업을 모두 대체 가능하나 실제 알고리즘에서는 while을 더 많이 사용한다.
                  중복된 코드가 여러개 분산되어 있는 경우를 스파게티 코드라고 하고 중복된 사항을 변경할 때 이러한 모든 코드를 찾아가는
                  것은 비효율적이기 때문에 반복문을 사용한다.
                  이때 for문은 특정 동작을 수행하기 때문에 보다 더 시간은 오래 걸릴 수 있으나 가독성과 유지보수 측면에서 사용한다.
                  경우에 따라 무조건 좋은 것은 아님
                  P.S. 대부분의 언어는 0부터 인덱스가 시작되나 R이나 Visual Basic은 1부터 인덱스가 시작된다.

 - for : loop보다는 iterator에 더 가까우나 while의 모든 기능을 대신 할 수 있어서 loop적인 요소로 사용된다.
    for(처음 한 번 수행하는 식; 판별식; 두번째 수행되는 식){
        반복할 내용;
    }
    처음 한 번 수행되는 식을 수행하고 판별식을 확인해서 falsy가 아니면 반복할 내용을 수행하고 이후 부터는 두번째 수행되는 식을 
    수행하고 판별식을 확인해서 falsy가 아니면이면 반복할 내용을 반복한다
    판별식이 Falsy가 되면 반복할 내용을 중지한다.
    ex> for( ; ; ){}


 - while : 표현식이 truthy라면 {}내용을 수행하고 다시 표현식으로 돌아와 표현식을 확인하고 Falsy가 될 때까지 {}을 수행한다.
    while(표현식){
        수행할 내용;
    }


 - do{}while : 표현식이 뒤에 있어서 {}의 내용을 어떤 상황속에도 1번은 수행된다, 기능적으로는 while과 동일하나 반드시 한번은
               수행되어야 한다는 의미전달을 위해 사용된다 -> sementic한 요소
    do{
        수행할 내용
    }while(표현식);

- for ~ in : 객체의 경우 속성 이름을 임시 변수에 순서대로 대임, 배열의 경우는 각 요소의 인덱스를 임시 변수에 대입 _ loop보다는 iterator요소

    for(임시변수 in 객체나 배열){
        수행할 내용
    }
    P.S iterator, loop 차이를 for ~ in으로 접근하는 것과 [index]로 접근하는 것의 차이로 확인할 수 있음


3. 제어문 작성 규칙
    - switch를 제외한 제어문에서 수행해야 할 내용이 한 줄이라면 {}는 생략가능.
    - 제어문안에서 제어문 사용이 가능하다.
    - 위의 경우에 안쪽 제어문에서 바깥쪽 제어문의 데이터를 사용하는 것이 가능하다.

4. 기타 제어문
    - break : switch 혹은 반복문의 수행을 종료하기 위한 명령어.
    - continue : 반복문에서 continue 아래 내용을 수행하지 않고 다음 반복으로 진행하기 위한 명령어
    - 특별한 경우를 제외하고 break나 continue는 if와 같이 사용된다.
    - return : 함수의 수행을 종료하고 0개 또는 하나의 데이터를 가지고 호출한 곳으로 돌아가도록 해주는 명령어.

5. document.write("*")은 *출력, 줄바꿈은 document.write("<br/>") 이를 이용해 *로 모양찍기 연습
    -> 중첩 for문을 사용하는데 내부 for문의 초기값, 판별식 변경을 사용해 조작하는 경우가 많다.
    -> 강의에서는 내부 for문의 판별식만을 변경해서 사용하길 권장, 초기값 변경시 판별식 증감값 모두 변경되어야 한다.
   
   <Ex>_문제_각 줄의 *은 차례대로 0~9 9이상이면 다시 0을 출력하고 ^은 공백으로
    ^^^^^*
    ^^^^*^*
    ^^^*^^^*
    ^^*^^^^^*
    ^*^^^^^^^*
    *^^^^^^^^^*
    ^^^^^^^^^^^ -> 아랫줄은 숫자(1~9,0,1)

6. Function
    - 개념 : 한 번에 수행해야 할 코드를 하나의 이름으로 묶어두고 사용하는 것으로 독립적으로 메모리를 할당 받아서 수행하게 됨
   
    - 목적 : 중복되는 코드를 방지하기 위해 사용한다.
             모듈화_코드를 읽기 좋고 실행하기 편리하게 분할한다.
    
    - 종류
        Maker Function : 언어 차원에서 제공하는 함수로 JS에서는 Window 객체가 제공한다.
        User Define Function : 개발자가 필요에 의해 생성한 것.
        3rd party Function : 다른 개발자가 만든 함수, 
                             해당 함수를 사용할 때는 보안이나 라이센스 문제를 생각해야 한다.(악의적인 함수가 종종 있음.)
                              <Ex) Python-pip install ~: 과 같이 따로 검증을 한다.>
                             지원이 언제 끊길지 모른다, 따라서 특정 단체가 만든것들을 위주로 사용하는 것을 권장.
    
    - JS에서 함수는 일급 객체 : 함수도 하나의 자료형으로 취급해 변수에 대입하거나 매개변수/반환값 으로 취급한다.
                               Callback(이벤트 발생시 호출되는 함수)함수를 이용해 함수의 매개변수로 함수를 대입받는 형태로 구현되기도 한다.
                               
                               Nested 함수 : 함수 안에 함수를 만드는 것이 가능하다.
                               High Order Function : 다른 함수를 반환하는 함수로 currying이라고도 하며, 디자인 패턴으로 간주하기도 한다.
                               Closure 함수 : 함수 안에서 함수를 반환해서 함수 외부에서 함수 내부의 데이터를 수정하는 것.

    - 함수를 선언한다 = 함수를 만든다.
        <예전 방식>
            Function 함수이름(매개변수 나열){
                수행내용
                return 데이터; // 없는 경우도 있음
            }
        -> 호이스팅이 발생할 가능성이 매우 높음

        <변수에 대입하는 방식>
            [var|let|const] 이름 = Function(매개변수 나열){
                수행 내용
                return 데이터; // 없는 경우도 있음
            }
        -> 권장

        <최근_화살표 함수>
            [var|let|const] 이름 = (매개변수 나열) => {
                수행 내용
                return 데이터; // 없는 경우도 있음
            }
        -> 매우 권장

    - 함수 호출(실행)
        <직접 호출> : 함수이름(매개변수 대입)
        <Call Back> : 상태변화나 이벤트가 발생하면 호출되는 것으로 특정 이벤트 발생시 자동으로 실행하도록 해주는 것

    - 함수의 구성
        이름 : 함수를 구별하기 위한 이름으로 자기영역에서 중복되면 안되고 중복될 시 내용이 사라진다.
        매개변수 : Parameter, argument, 인자, 인수 등을 의미한다. 
                  함수를 호출 할 때 넘겨주는 데이터. Parmr과 Argum의 차이는 함수 외/내부에서 바라보는 시각차이 정도
        return : 함수의 코드를 실행하고 호출한 곳에 넘겨주는 데이터(결과 값)

    - Argument(=Parameter, 매개변수, 인자, 인수)
        함수를 호출할 때 호출하는 쪽에서 넘겨주는 데이터
        파라미터가 없는 함수는 항상 동일한 작업만 수행 가능

        함수 선언 : var 함수이름 = function(매개변수 이름 나열){
                                        //함수가 수행할 작업
                                    }
        함수 호출 : 함수이름(매개변수에 대입할 데이터 나열)

        매개변수는 상황에 따라 없을 수도 여러개일 수 있다.
        매개변수는 함수 내의 지역변수가 된다, 함수 외부에서 사용불가.

        매개변수에 하나의 데이터를 저장하는 기본형 데이터를 대입하면 함수 내에서 데이터를 변경해도 원본에는 아무런 영향이 없고
        (이전에는 Call By Value라고 했음) 0개 이상의 데이터를 가진 배열이나 객체를 대입한 경우 함수 내에서 배열이나 객체의 
        내부 요소를 변경하면 원본의 내용도 변경된다(이전에는 Call By Reference라고 함.).

        arguments 배열
        함수 내의 만들어진 숨겨진 변수로 매개변수에 데이터를 대입하면 순서대로 저장하고 있는 배열로 JS에서 매개변수 보다 더 많은
        양의 데이터를 대입하면 매개변수 개수 만큼 매개변수에 대입하고 나머지는 arguments 배열에서 찾아서 사용할 수 있음
        반대로 매개변수보다 적게 대입하면 앞에서부터 순서대로 채워지고 나머지는 undefined가 된다.

      - return : 함수의 수행을 종료하고 하나의 데이터를 호출한 곳으로 넘겨주고자 할 때 사용하는 명령어이다.
                 return 뒤의 문장은 수행되지 않는다.

      - Pure Function(순수함수) : 동일한 입력에 동일한 출력을 만들어야 한다.
                                 외부 데이터를 변경하지 않아야 하며, 결과를 return해서 값을 주어야 한다.

      - Recursion(recursive call - 재귀) : 함수가 자기 자신의 함수를 반환하는 경우
                                           재귀를 사용하면 코드의 가독성이 높아지나 메모리 사용량이 많아지고 시간이 오래 걸릴 수 있음

    - 함수의 매개변수에 기본값 설정이 가능 : 매개변수 이름 뒤에 =과 함께 값을 설정하면 된다

    - 화살표 함수 : ECMA 2015에 추가된 문법, 함수를 아래처럼 작성
                   (매개변수 나열) =>{함수의 내용}
                   함수의 매개변수가 1개이면 ()생략가능, 함수의 내용이 한 줄 이면 {}생략 가능.
                   마지막 수행되는 문장의 결과를 return.
                   함수 내부에서 this와 arguments를 사용할 수 없음, arguments대신에 rest를 사용
                   =>의 앞에서 줄 바꿈하면 Error발생 뒤에서는 상관없음, 주로 Callback함수로 설정할 때 사용한다.


P.S. 변수, 제어문, 함수, 상속, 클래스 등 모든 것을 사용하는 근본적인 이유는 반복되는 코드를 줄이기 위해서이다.
     계속 리팩토링 되는 이유는 사실 전형적인 틀 외에는 코드를 짜봐야 동일한 결과값을 갖는 것에 대해 클래스, 상속, 제어문등 무엇을 사용할지 모르기
     때문에 나중에 개선되어 나가는 것 -> 경험치가 그래서 중요


P.S. DATA 분류(C++이후 언어들은 value type data를 없애버렸다.)
        - value type : 변수에 데이터 자체를 보관(C, C++)
                       EX> int a = 10; int *x = &a 일때, Stack에 10의 해쉬코드(주소라고 생각)를 넣어둠

        - Reference type : 변수에 데이터의 참조(실제 데이터의 해쉬코드)를 보관
                           포인터가 없어진 이유는 포인터 접근시 조금 더 속도를 향상하는 효과가 있지만, 
                           Stack의 용량이 한정되어 있기 때문에 많은 양을 만들어 내지 못하고 현재 컴퓨터의 속도가
                           포인터 없이도 충분히 빠른 작업을 수행할 수 있기 때문에 없어지는 것이 자연스러운 것.
                           
        - scala : 기본형 변수로 변수가 데이터 자체를 가리킴
                  var a = 10, var b = a 와 같이 대입 시 복제가 된다. 허나 b에는 10이 저장되나 실제로는 아무상관이 없음.
                  즉, b의 값이 바뀐다고, a의 값이 바뀌지 않는다.

        - vector : 변수가 대표하는 곳의 참조를 가지고 있다.
                   var a = ar[1, 2], var br = ar 일때, br과 ar은 같은 곳의 참조를 가지게 된다.
                   즉, 같은 공간을 가리키고 있기 때문에 br에 대한 접근으로 ar의 값들에도 영향을 미친다.

P.S. 코드를 처음 호출 할 때, 호출 스택(Queue)에서 불러들이는데 이는 OS에 주관한다.
     또한 그냥 Stack의 주인은 함수가 되게 되는데, 함수가 실행 될 때마다 Stack이 하나씩 생성된다.
     하지만 함수와 클래스는 Heap에 저장되게 되는데, 리터럴/상수/함수/클래스와 인스턴스가 Heap내에서 따로 분류되어 들어간다.
     전자는 메모리 해제나 크기 변경이 불가능한 Static한 공간.
     즉 선언되었다는 것은 불러드린다는 것이기 때문에 전자와 같은 Static한 Heap공간에 모아둔다.
     하지만 인스턴스가 담긴 공간은 동적이고 메모리 해제나 크기 변경이 가능하다.

     함수가 호출되면 Stack이 생성되고 해당 Stack은 호출 Stack에서 실제 함수에대한 권한을 부여 받는데, 함수 수행후 권한을 호출 Stack에 넘겨
     줘야하고 이를 위해 return을 사용한다, 또한 처음 호출된 함수 안에서 다른 함수를 호출하면 또 다른 Stack이 생기고 권한을 상위 Stack으로 부터 받아
     다시 반환해야 하는 형태이다.

7. Built In(내장) Function

    - JS에서 제공하는 함수로 실제로는 window 객체의 메서드인데 window객체를 이용해 내부 요소를 호출할 때는 window.을 
      생략할 수 있어서 전역함수 처럼 사용한다.

    - alert : 메시지를 대화상자에 출력할 때 사용하는 함수 -> alert(message); return데이터가 없다.
    
    - confirm : 메시지를 대화상자에 출력하고 버튼을 2개 제공하는데 확인 버튼을 누르면 true가 취소 버튼을 누르면 false가 반환된다.

    - prompt : 한 줄의 문자열을 입력받을 수 있는 대화상자로 prompt(메시지, 기본값)으로 호출하고 확인과 취소 버튼이 만들어지는데 
               확인을 누르면 입력한 문자열이 반환되고 취소를 누르면 null이 반환된다.
    
    - eval : 문자열을 대입하면 이에 해당되는 DOM객체를 찾아서 반환해주는 함수였지만, 현재는 
             document.getElementById를 권장하기 때문에 거의 사용되지 않는다.

    - 인코딩 및 디코딩 관련 함수

        Encoding : 데이터를 컴퓨터에 저장하는 형태로 만드는 것.
                   JS에서 서버에게 데이터를 전송할 때 GET 방식을 사용하는 경우 Query string(parameter)은 반드시 encoding을 해서 
                   전송해야 한다.
                   -> 이때, QueryString에 한글이 포함되어 있는데 encoding하지 않고 전송하면 글자가 깨진다.

                   escape(문자열) : 일부 특수문자(@, *, -, _, +, ., /)를 제외한 모든 문자를 인코딩
                   encodingURI : 인터넷 주소에 사용되는 문자를 제외한 모든 문자를 인코딩
                   encodingURIComponent(문자열) : 알파벳과 숫자를 제외한 모든 문자를 인코딩

        Decoding : 컴퓨터에 저장된 데이터를 출력하기 위한 형태로 만드는 것.
                   
                   unescape
                   decodeURL
                   decodeURIComponent

    - isNaN : NaN 여부를 판단함수(P.S. is~로 시작되는 것은 Boolean)

    - isFinite : 유한수 인지 판다하는 함수

    - ParseInt/ParseFloat : 문자열을 정수나 실수로 변경해주는 함수

    ** JS의 OOP객체 지향 프로그래밍, ES5까지는 클래스의 개념이 없어서 OOP의 개념이 아님 
       객체 기반 언어 ECMA 2015에서 클래스 개념이 도입됨

 8. 객체지향의 3대 특징
    - Encapsulation() : 불필요한 부분을 숨기고 만드는 것
                        클래스를 만드는 것과 인스턴스를 만드는 것 그리고 지정자률 학습
    
    - Inheritance(상속) : 하위 클래스가 상위 클래스의 모든 것을 물려 받는 것

    - polymorphsim(다형성) : 동일한 메시지에 대해 다르게 반응하는 성질
                            동일은 코드가 호출하는 객체에 따라 다른 메서드를 호출하는 성질
                            상속과 오버라이딩(가끔은 오버라이딩이 아니라 구현)으로 구현됨

 9. 객체(Object) : 데이터를 저장할 수 있는 속성(variable - property)과 기능을 수행하는 메서드(function - method)
                   모아 놓은 것.

                   종류
                   사용자 정의 객체 : 개발자가 필요에 의해서 생성하는 것
                                     생성
                                     - var(let or const) 이름 = {"속성이름" : 데이터, "메서드이름" : 메서드 코드..}
                                     - var(let or const) 이름 = new 생성자(매개변수 나열)
                                     
                                     내부 요소 호출
                                     - 이름.속성이름
                                     - 이름.메서드이름(매개변수)
                                     -> .이름 대신에 [속성이름]으로 속성 호출이 가능한데 이 때 문자열 형태로 입력해야 한다.
                                        var obj = {"name" : "adam"}; 
                                        obj.name == obj["name"]
                                     - 내부 속성은 중복해서 만들어지지 않으므로 동일한 이름에 2번 삽입하면 내용이 없어지고 새로운 내용으로 변경된다. 
                                     - for(임시변수 in 객체이름){수행할 내용} : 객체의 모든 속성의 이름을 임시변수에 문자열 형태로 대입하고 {}안의 내용을 반복수행
                                     - "속성이름" in 객체 : 속성이 객체에 존재하는지 여부를 판단해서 Boolean값으로 반환
                                     - with 블럭
                                       with(객체이름){ // 해당 블록 내에서는 객체이름 생략가능 }
                                     - 속성 추가 및 수정
                                       객체이름.속성이름 = 데이터 또는 함수;
                                       
                   내장 객체 : JS에서 제공하는 객체 - API(Application Programing Interface) 나 SDK(Software Development Kit)
                               라고 함
                   3rd Party객체 : 다른 개발자나 회사가 제공 (Library, Framework : Solution)
                                   라이브러리는 제 3자가 많이 쓰는 기능/틀을 제공하는 정도
                                   프레임워크는 프로젝트 하나를 만들 정도로 제공하는 정도
                                   솔루션은 학사정보 시스템과 같은 것을 만드는데 어느정도 핵심 틀이 있는 사람


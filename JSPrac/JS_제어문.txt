제어문 : 기본적인 명령의 흐름은 왼쪽에서 오른쪽으로, 위에서 아래로 흐른다.
         이런 명령의 흐름을 변경하는 명령어가 제어문에 해당된다.

1. 분기문 : 조건이나 값에 따라 다른 문장을 수행하는 것과

 - if문
   if(표현식){
        표현식이 Truthy일 때 수행할 내용
   } else if {
        앞의 표현식이 Fasly이고 현재 표현식이 Truthy일 때 수행할 내용
   } else {
        앞의 모든 식이 Falsy일 때 수행할 내용
   }
-> else if 는 0개 이상 여러번 작성가능하고 else는 생략하거나 1번만 작성해야 한다.
   if와 else if, else는 별도의 블록으로 처리되어야 하고 가장 위의 표현식이 T라면 아래 표현식은 확인하지 않는다.
   그러므로 항상 분기문 사용시 가장 T가 많은 경우를 가장 윗줄의 표현식(조건문)을 삽입해 효율을 올리고 늘 주석으로 이를 알린다
   feat(코딩테스트)_전체를 못해도 중간까지 하는게 이득


 - switch문 : 값에 의한 분기
   switch(표현식){
        case x : 
            표현식이 x인 경우에 수행할 내용
            break;
        
        case y : 
            표현식이 y인 경우에 수행할 내용
            break;
        ....
        default :
            표현식이 x, y, .... 앞의 어디에도 해당되지 않을 경우 수행할 내용
            break;
   }
   -> 각 case당 break;없을 시 break를 만날 때까지 모든 case에 대한 수행을 하게된다, default 키워드 문 자체와 그 안의 break는 생략가능
      값에 자리에는 반드시 값이 아닌 또 다른 표현식이 와도 상관없다.
      case문은 여러개가 올 수 있지만, 생략불가
      switch(true){}로 작성하고 내부 case문에 Boolean표현식을 작성해 사용하는 경우도 있음


2. 반복문(Loop) : for가 while의 작업을 모두 대체 가능하나 실제 알고리즘에서는 while을 더 많이 사용한다.
                  중복된 코드가 여러개 분산되어 있는 경우를 스파게티 코드라고 하고 중복된 사항을 변경할 때 이러한 모든 코드를 찾아가는
                  것은 비효율적이기 때문에 반복문을 사용한다.
                  이때 for문은 특정 동작을 수행하기 때문에 보다 더 시간은 오래 걸릴 수 있으나 가독성과 유지보수 측면에서 사용한다.
                  경우에 따라 무조건 좋은 것은 아님
                  P.S. 대부분의 언어는 0부터 인덱스가 시작되나 R이나 Visual Basic은 1부터 인덱스가 시작된다.

 - for : loop보다는 iterator에 더 가까우나 while의 모든 기능을 대신 할 수 있어서 loop적인 요소로 사용된다.
    for(처음 한 번 수행하는 식; 판별식; 두번째 수행되는 식){
        반복할 내용;
    }
    처음 한 번 수행되는 식을 수행하고 판별식을 확인해서 falsy가 아니면 반복할 내용을 수행하고 이후 부터는 두번째 수행되는 식을 
    수행하고 판별식을 확인해서 falsy가 아니면이면 반복할 내용을 반복한다
    판별식이 Falsy가 되면 반복할 내용을 중지한다.
    ex> for( ; ; ){}


 - while : 표현식이 truthy라면 {}내용을 수행하고 다시 표현식으로 돌아와 표현식을 확인하고 Falsy가 될 때까지 {}을 수행한다.
    while(표현식){
        수행할 내용;
    }


 - do{}while : 표현식이 뒤에 있어서 {}의 내용을 어떤 상황속에도 1번은 수행된다, 기능적으로는 while과 동일하나 반드시 한번은
               수행되어야 한다는 의미전달을 위해 사용된다 -> sementic한 요소
    do{
        수행할 내용
    }while(표현식);

- for ~ in : 객체의 경우 속성 이름을 임시 변수에 순서대로 대임, 배열의 경우는 각 요소의 인덱스를 임시 변수에 대입 _ loop보다는 iterator요소

    for(임시변수 in 객체나 배열){
        수행할 내용
    }
    P.S iterator, loop 차이를 for ~ in으로 접근하는 것과 [index]로 접근하는 것의 차이로 확인할 수 있음


3. 제어문 작성 규칙
    - switch를 제외한 제어문에서 수행해야 할 내용이 한 줄이라면 {}는 생략가능.
    - 제어문안에서 제어문 사용이 가능하다.
    - 위의 경우에 안쪽 제어문에서 바깥쪽 제어문의 데이터를 사용하는 것이 가능하다.

4. 기타 제어문
    - break : switch 혹은 반복문의 수행을 종료하기 위한 명령어.
    - continue : 반복문에서 continue 아래 내용을 수행하지 않고 다음 반복으로 진행하기 위한 명령어
    - 특별한 경우를 제외하고 break나 continue는 if와 같이 사용된다.
    - return : 함수의 수행을 종료하고 0개 또는 하나의 데이터를 가지고 호출한 곳으로 돌아가도록 해주는 명령어.

5. document.write("*")은 *출력, 줄바꿈은 document.write("<br/>") 이를 이용해 *로 모양찍기 연습
    -> 중첩 for문을 사용하는데 내부 for문의 초기값, 판별식 변경을 사용해 조작하는 경우가 많다.
    -> 강의에서는 내부 for문의 판별식만을 변경해서 사용하길 권장, 초기값 변경시 판별식 증감값 모두 변경되어야 한다.
   
   <Ex>_문제_각 줄의 *은 차례대로 0~9 9이상이면 다시 0을 출력하고 ^은 공백으로
    ^^^^^*
    ^^^^*^*
    ^^^*^^^*
    ^^*^^^^^*
    ^*^^^^^^^*
    *^^^^^^^^^*
    ^^^^^^^^^^^ -> 아랫줄은 숫자(1~9,0,1)

6. Function
    - 개념 : 한 번에 수행해야 할 코드를 하나의 이름으로 묶어두고 사용하는 것으로 독립적으로 메모리를 할당 받아서 수행하게 됨
   
    - 목적 : 중복되는 코드를 방지하기 위해 사용한다.
             모듈화_코드를 읽기 좋고 실행하기 편리하게 분할한다.
    
    - 종류
        Maker Function : 언어 차원에서 제공하는 함수로 JS에서는 Window 객체가 제공한다.
        User Define Function : 개발자가 필요에 의해 생성한 것.
        3rd party Function : 다른 개발자가 만든 함수, 
                             해당 함수를 사용할 때는 보안이나 라이센스 문제를 생각해야 한다.(악의적인 함수가 종종 있음.)
                              <Ex) Python-pip install ~: 과 같이 따로 검증을 한다.>
                             지원이 언제 끊길지 모른다, 따라서 특정 단체가 만든것들을 위주로 사용하는 것을 권장.
    
    - JS에서 함수는 일급 객체 : 함수도 하나의 자료형으로 취급해 변수에 대입하거나 반환할 수 있다.

    - 함수를 선언한다 = 함수를 만든다.
        <예전 방식>
            Function 함수이름(매개변수 나열){
                수행내용
                return 데이터; // 없는 경우도 있음
            }
        -> 호이스팅이 발생할 가능성이 매우 높음

        <변수에 대입하는 방식>
            [var|let|const] 이름 = Function(매개변수 나열){
                수행 내용
                return 데이터; // 없는 경우도 있음
            }
        -> 권장

        <최근_화살표 함수>
            [var|let|const] 이름 = (매개변수 나열) => {
                수행 내용
                return 데이터; // 없는 경우도 있음
            }
        -> 매우 권장

    - 함수 호출(실행)
        <직접 호출> : 함수이름(매개변수 대입)
        <Call Back> : 상태변화나 이벤트가 발생하면 호출되는 것으로 특정 이벤트 발생시 자동으로 실행하도록 해주는 것

    - 함수의 구성
        이름 : 함수를 구별하기 위한 이름으로 자기영역에서 중복되면 안되고 중복될 시 내용이 사라진다.
        매개변수 : Parameter, argument, 인자, 인수 등을 의미한다. 
                  함수를 호출 할 때 넘겨주는 데이터. Parmr과 Argum의 차이는 함수 외/내부에서 바라보는 시각차이 정도
        return : 함수의 코드를 실행하고 호출한 곳에 넘겨주는 데이터(결과 값)
    
P.S. 변수, 제어문, 함수, 상속, 클래스 등 모든 것을 사용하는 근본적인 이유는 반복되는 코드를 줄이기 위해서이다.
     계속 리팩토링 되는 이유는 사실 전형적인 틀 외에는 코드를 짜봐야 동일한 결과값을 갖는 것에 대해 클래스, 상속, 제어문등 무엇을 사용할지 모르기
     때문에 나중에 개선되어 나가는 것 -> 경험치가 그래서 중요